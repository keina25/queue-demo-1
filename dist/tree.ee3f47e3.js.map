{"version":3,"sources":["tree.js"],"names":["createTree","value","data","children","parent","addChild","node","newNode","push","travel","tree","fn","i","length","find","result","undefined","removeNode","siblings","index","splice","node2","node3","node4","node5","console","log"],"mappings":"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","file":"tree.ee3f47e3.js","sourceRoot":"..\\src","sourcesContent":["const createTree = value =>{\r\n    return{\r\n        data:value,\r\n        children:null,\r\n        parent:null,\r\n    };\r\n};\r\n\r\nconst addChild = (node,value)=>{\r\n    const newNode = {\r\n        data:value,\r\n        children:null,\r\n        parent:node,\r\n        //往一个节点添加儿子的时候，默认把这个儿子的爸爸parent记为这个节点\r\n    };\r\n    node.children = node.children || []\r\n    node.children.push(newNode);\r\n    return newNode\r\n};\r\n\r\nconst travel = (tree,fn)=>{\r\n    //debugger \r\n    //有问题可以用这个看一下运行过程\r\n    fn(tree)\r\n    //fn接受是一个节点，而不是一个节点的data\r\n    //遍历根节点\r\n    if(!tree.children){\r\n        return;\r\n    }\r\n    //如果不加这个children不为空的话，输出的时候，会提示有children等于空\r\n    for(let i = 0; i < tree.children.length;i++){\r\n        travel(tree.children[i],fn);\r\n        //传进了children，fn这里是传出去\r\n        //这里再遍历子节点的每一个节点\r\n    };\r\n};\r\n\r\nconst find = (tree,node) =>{\r\n    if(tree === node){\r\n        return tree\r\n        //如果那个节点有再这个根节点里，就回到tree里\r\n    }else if(tree.children){\r\n        for(let i = 0; i<tree.children.length;i++){\r\n           const result = find(tree.children[i],node)\r\n           if(result){return result};\r\n           //如果有儿子，就回到儿子里面那个结果\r\n        };\r\n        return undefined\r\n        //如果儿子里面都没找到，就回到undefined\r\n    }else{\r\n        return undefined\r\n        //如果不是在根节点和儿子里面，就回到undefined\r\n    };\r\n};\r\n\r\nconst removeNode = (tree,node) =>{\r\n    const siblings = node.parent.children;\r\n    //siblings是兄弟姐妹等于爸爸的孩子\r\n    //删除节点，就是找到爸爸的儿子们，看看爸爸的儿子排第几\r\n    let index = 0;\r\n    for(let i =1; i<siblings.length;i++){\r\n        if(siblings[i] === node){\r\n           index = i;\r\n        };\r\n    };\r\n    siblings.splice(index,1);\r\n    //然后从数组里面给删掉\r\n};\r\n//删除节点，不是把这个节点搞没，是把这个节点在这个树的里面的地址搞没\r\n\r\nconst tree = createTree(10);\r\nconst node2 = addChild(tree,20);\r\n//在20这个节点在增加新的节点，\r\n//需先返回newNode，然后node2等于这个值（const）后，\r\n//就可以在20后面加新的节点\r\nconst node3 = addChild(tree,30);\r\n//删除node3,先遍历，\r\n//确保这个节点在这个数里面const travel = ()\r\nconst node4 = addChild(tree,40);\r\nconst node5 = addChild(tree,50);\r\naddChild(node2,201);\r\naddChild(node2,202);\r\naddChild(node2,203);\r\naddChild(node2,204);\r\nconsole.log(tree);\r\n\r\nconst fn = node =>{\r\n    console.log(node.data)\r\n}\r\n//travel(tree,fn);\r\n//遍历数组,从原本的travel(tree,node =>(console.log(node.data));\r\n//改成了上面const fn = node=>{console.log}\r\n//这样更适合打断点，debugger\r\n\r\n//console.log(find(tree,node2));\r\n//在那棵树里，找到那个2，验证是否能找到20\r\n\r\nremoveNode(tree,node5);\r\nconsole.log(tree);"]}